# Comprehensions in python are comprised sytax to define 
#   Lists
#   Sets
#   Dictionaries
# in a declarative or functional styles

words = "Why sometimes I have believed as many as six impossible things before breakfast".split()
words

# ###1 - List comprehension
# comprehensions - are generally included in square brackets, just like literal lists, 
# but istead of literal elementes it contains fragment of declarative code which describes how to construct the elements of list
[len(word) for word in words] # creates a new list of integers representing length of each item

# BESTPRACTICE General form of list comprehension looks like this
# [expr() for item in iterable]
# This is similar to the imperative code as shown below. 
# Although the list from which we are looping through can be any iterable object such as a tuple
lengths = []
for word in words:
    lengths.append(len(word))

###2 Complex list comprehension
from math import factorial
f = [len(str(factorial(x))) for x in range(20)]
f #[1, 1, 1, 1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18]
type (f) # <class 'set'>

###3 set comprehension with curly braces
# {expr(item) for item in iterable}
# In the above example you can see there are lot of duplicates
# With set you can remove those duplicates by default
f = {len(str(factorial(x))) for x in range(20)}
f # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18}. Note that this is not necessarily in the order as list are not have order items
type (f) # <class 'set'>

###4 Dictionary Comprehensions
# This also uses curly braces
# This is differentiated from set comprehension by the fact that now we provide two colon (:) seprated expressions
# Key and value is evaluated in tandem for each item
from pprint import pprint as pp
countries_to_capital = {"India":"New Delhi",
                        "England": "London",
                        "United States": "Washington DC",
                        "Brazil": "Brazilia",
                        "Moroco": "Rabat",
                        "Sweden": "Stockholm"}

# Once nice ways of dictionary comprehensions is to invert the dictionary to perform look up in oppposite direction
# IMPORTANT Dictionary comprehension do not usually operate directly on the dictionary sources. 
# While they can, they will yield only the keys
# If we want both keys and values, we should use the items method of the dictionary and use tuple unpacking to extract keys and values separately
capital_to_country = {capital:country for country, capital in countries_to_capital.items()}
pp(capital_to_country)

###5 Identical keys generated by comprehension, later keys will replace earlier keys
words = ["hi", "hello", "foxtrot", "hotel"]
map = {x[0]:x for x in words}
map # {'h': 'hotel', 'f': 'foxtrot'}

# BESTPRACTICE Following is the close to the limit of the complexity reasonable for comprehension
# Recommendation is to express complex expressions into separate functions
# Dont cram too much complexity into comprehensions
import os
import glob
file_sizes = {os.path.realpath(p): os.stat(p).st_size
            for p in glob.glob("*.py")}
pp(file_sizes)

